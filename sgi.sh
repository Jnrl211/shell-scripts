#!/bin/bash
# 
# [S]et [G]itHub SSH [i]dentity script
# 
# A shell script to easily change or select a different SSH identity on a local repository
# 
# This script changes the SSH key (and its associated GitHub account) used in Git commands to pull and push changes to a remote repository,
# use it if you make a mistake when cloning a repository with "igr_and_sgi.sh" or simply if you cloned a repository using Git commands,
# and for whatever reason you need to change the SSH key of said repository.
# 
# Arguments
# - Identity name (script will look for a public and private key with this name in the SSH keys folder: "~/.ssh" or "%USERPROFILE%\.ssh")
# - Repository Local directory (if destination doesn't exist, the script doesn't perform any changes)

function test_identity() {
    local identity="$1"
    local private_key_file=$1
    local public_key_file="$1.pub"
    local user_name_file="$1.username"
    local user_no_reply_email_file="$1.noreplyemail"
    local is_failed=0
    # TODO: add check for forbidden names
    # Checks whether the identity files of the selected identity exist in the ~/.ssh folder
    # grep produces a multi-line string containing the file names that match the regex: each regex below is designed so grep only finds a single file if it exists, using ERE,
    # the output of ls is piped to grep so the output of ls acts as the input of grep, as a file stream
    if [[ $(ls ~/.ssh | grep -E "^$identity$") != "$private_key_file" ]]; then
        echo Private key file not found
        is_failed=1
    fi
    if [[ $(ls ~/.ssh | grep -E "^$identity\.pub$") != "$public_key_file" ]]; then
        echo Public key file not found
        is_failed=1
    fi
    if [[ $(ls ~/.ssh | grep -E "^$identity\.username$") != "$user_name_file" ]]; then
        echo User name file not found
        is_failed=1
    fi
    if [[ $(ls ~/.ssh | grep -E "^$identity\.noreplyemail$") != "$user_no_reply_email_file" ]]; then
        echo No-reply e-mail file not found
        is_failed=1
    fi
    # Check if there was at least a missing file
    if [ $is_failed -eq 1 ]; then 
        echo "Failed to find identity files, please ensure the ~/.ssh folder contains the following files of your Git/GitHub identity:"
        echo "- Private SSH key (e. g. my_id)"
        echo "- Public SSH key (e. g. my_id.pub)"
        echo "- User name (e. g. my_id.username)"
        echo "- No-reply e-mail (e. g. my_id.noreplyemail)"
        return 1
    fi
    return 0
}

function test_destination() {
    local destination="$1"
    local destination_parent_directory="$(dirname "$(readlink -f "$destination")")"
    # Check if the parent directory exists
    if [ ! -d "$destination_parent_directory" ]; then
        echo "Failed to process destination, parent directory does not exist"
        return 1
    fi
    # Check if the parent directory is writable
    if [ ! -w "$destination_parent_directory" ]; then
        echo "Failed to process destination, no write permission in the parent directory"
        return 1
    fi
    return 0
}

function set_repository_identity() {
    # If destination doesn't exist, does nothing and exits
    # If destination exists, changes the Git identity user name, no-reply e-mail and SSH keys of the local repository
    local identity="$1"
    local destination="$2"
    local git_path="$3"
    # eval is necessary here so "~" expands properly if contained in the destination argument, because "~" doesn't expand to the user directory when in quotes, only without them
    if [ -d $(eval echo "$destination") ]; then
        echo "info: destination $destination exists"
    else
        echo "info: destination $destination doesn't exist"
        return 1
    fi
    cd "$destination"
    # Calling git commands inside a folder that is not a git repository is ineffectual and harmless, otherwise, everything works as intended
    $git_path config --local core.sshCommand "ssh -i ~/.ssh/$identity"
    $git_path config --local user.name "$(cat ~/.ssh/$identity.username)"
    $git_path config --local user.email "$(cat ~/.ssh/$identity.noreplyemail)"
    # Return the last exit code: if git succeeds, it should return exit code 0 as usual, if it fails, it will produce a non-zero exit code
    return $?
}

# Replace this variable with the executable path of Git if it is not accessible from its shell alias
# TODO: add code to replace this value with optional argument provided by the user
git_path="git"
is_valid_identity=1
is_valid_destination=1
options=$(getopt -o hi:d: -l help,identity:,destination: -- "$@")
if [ $? -ne 0 ]; then
    echo "Failed to parse options, exiting"
    exit 1
fi
# "eval" is necessary because it expands the arguments before passing them to set
eval set -- $options
# This block only runs if no options were found, so the only option present is the "--" generated by set. Defaults to setting the script to help mode
if [[ $# -eq 1 ]]; then
    # If no arguments are provided by the user, defaults to showing the help message only
    # Add "--" before passing positional arguments so they are interpreted as options for the script, not as options for "set"
    set -- -h --
fi
# Argument parsing loop
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            # Customize this help message if more arguments are added to the script
            echo "Usage: $0 [-h|--help] [-i|--identity <identity>] [-d|--destination <destination>]"
            echo "- identity - GitHub SSH identity"
            echo "- destination - Local repository path"
            exit 0
            ;;
        -i|--identity)
            identity="$2"
            test_identity "$identity"
            is_valid_identity=$?
            shift
            ;;
        -d|--destination)
            destination=$2
            test_destination "$destination"
            is_valid_destination=$?
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Invalid option: $1"
            exit 1
            ;;
    esac
    shift
done
# Argument validation checks
if [ $is_valid_identity -ne 0 ]; then
    echo "Identity argument not provided, or not valid"
fi
if [ $is_valid_destination -ne 0 ]; then
    echo "Destination argument not provided, or not valid"
fi
if [ $is_valid_identity -ne 0 ] || [ $is_valid_destination -ne 0 ]; then
    echo Failed to set Git repository identity, at least one of the arguments is not valid
    exit 1
fi
set_repository_identity "$identity" "$destination" "$git_path"
return $?